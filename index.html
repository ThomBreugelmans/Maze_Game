<!DOCTYPE html>
<head>
    <title>A maze game</title>
    <style>
        * {
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            min-height: 90vh;
        }

        button {
            font-size: 1.2em;
        }


        #configure-menu {
            display: none;

            position: absolute;
            top: 135px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;

            padding: 20px 50px 75px 50px;
            background-color: rgb(94, 73, 104);
            border-radius: 30px;
            color: lightgray;
        }
        #configure-menu > div {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 30px;
        }
        #configure-menu > div > div:first-of-type {
            display: flex; 
            justify-content: space-between; 
            flex-direction: row; 
            gap: 20px;
        }

        .dropdown-menu-arrow {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translate3d(-50%, -100%, 0);
        }

        #close-configure-menu-btn {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        #close-configure-menu-btn:hover {
            cursor: pointer;
        }
        #close-configure-menu-btn > #b {
            display:none;
        }

        #generate-maze-btn {
            margin-top: 30px;
        }

        #generate-maze-btn, #configure-btn {
            padding: 10px 30px 10px 30px;
            background-color: rgb(94, 49, 94);
            color: lightgray;
            border: none;
            border-radius: 20px;
        }
        
        
        #up, #down, #left, #right {
            display: none;
            background-color: rgba(32, 32, 32, 0.76);
            font-size: calc(1em + 2vh);
            color: white;
        }
        #up {
            left: 50%;
            top: 95%;
            transform: translate3d(-50%, -220%, 0);
        }
        #down {
            left: 50%;
            top: 95%;
            transform: translate3d(-50%, -100%, 0);
        }
        #left {
            left: 22%;
            top: 95%;
            transform: translate3d(-110%, -100%, 0);
        }
        #right {
            left: 78%;
            top: 95%;
            transform: translate3d(10%, -100%, 0);
        }
        #canvaswrapper {
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
        }
        #maze, #maze-overlay {
            position: absolute;
            left: 50%;
            top: 0px;
            transform: translateX(-50%);
            margin-bottom: 50%;
        }
        @media only screen and (max-width: 1500px) {
            #close-configure-menu-btn > #a {
                display: none;
            }
            #close-configure-menu-btn > #b {
                display: block;
            }

            #configure-menu {
                top: 0;
                min-width: 100vw;
                min-height:100vh;
                padding-top: 50px;
            }
            #configure-menu > div:first-of-type {
                top: 50px;
                right: 50px;
            }
            #configure-menu > div:last-of-type {
                font-size: 3em;
                position: absolute;
                left:50%;
                transform: translateX(-50%);
            }
            #configure-menu > div > div:first-of-type {
                justify-content: space-around;
            }
            #width #height {
                font-size: 3em;
            }

            button {
                font-size: 50px;
                width: 80vw;
            }

            #up, #down, #left, #right {
                display: block;
            }
        }
    </style>
</head>
<body style="background-color: rgb(27, 18, 29);">
    <div id="configure-menu">
        <svg height="15" width="40" class="dropdown-menu-arrow">
            <polygon points="20,0 21,0 22,0 23,1 24,1 25,3 26,4 40,15 0,15 16,1 15,3 14,4 17,1 18,0 19,0" fill="rgb(94, 73, 104)"/>
        </svg>
        <div id="close-configure-menu-btn" ontouch="document.getElementById('configure-menu').style.display = 'none'" onclick="document.getElementById('configure-menu').style.display = 'none'">
            <svg id="a" width="10" height="10">
                <line x1="0" y1="0" x2="10" y2="10" stroke="lightgray" />
                <line x1="0" y1="10" x2="10" y2="0" stroke="lightgray" />
            </svg>
            <svg id="b" width="50" height="50">
                <line x1="0" y1="0" x2="50" y2="50" stroke="lightgray" stroke-width="3" />
                <line x1="0" y1="50" x2="50" y2="0" stroke="lightgray" stroke-width="3" />
            </svg>
        </div>

        <div>
            <h3 style="border-bottom-style: solid; border-bottom-width: 1px; margin-bottom: 0;">Configuration Menu</h3>
            <div>
                <span><p style="color: rgb(211, 211, 211); margin: 5px 5px 5px 2px;">Width:</p><input type="number" id="width" name="width" value="30" min="5" max="100"></span>
                <span><p style="color: lightgray; margin: 5px 5px 5px 2px;">Height:</p><input type="number" id="height" name="height" value="30" min="5" max="100"></span>
            </div>
            <div>
                <input type="number" id="speed" name="speed" value="1.0" min="0.5" max="2.0" step="0.1" />
                    <label for="coins">speed multiplier</label>
            </div>
            <div>
                <input type="checkbox" id="coins" name="coins" />
                    <label for="coins">enable coins</label>
            </div>
            <div>
                <input type="checkbox" id="flashlight" name="flashlight" />
                    <label for="flashlight">enable flashlight</label>
            </div>

            <button id="generate-maze-btn" ontouch="start()" onclick="start()">Generate/Start</button>
        </div>
    </div>
    <div style="text-align: center;">
        <h1 style="color: lightgray;">THE MAZE GAME</h1>
        <button id="configure-btn" ontouch="document.getElementById('configure-menu').style.display = 'block'" onclick="document.getElementById('configure-menu').style.display = 'block'">Configure Maze</button>
        <div id="flexbox" style="display: flexbox; justify-content: space-evenly; margin-left: auto; margin-right: auto;">
        </div>
        <br>
        <hr>
        <br><br><br>
        <p id="timer" style="position: relative; width: 50%; margin-left: 25%; margin-right: 25%; font-family: 'Roboto', sans-serif; color: lightgray; text-align: center; z-index: 4;">0H 0m 0s</p>
        <div id="canvaswrapper">
            <canvas id="maze" style="z-index: 2;"></canvas>
            <canvas id="maze-overlay" style="display: none; z-index: 3;"></canvas>
        </div>
        <canvas id="fireworks" width="100%" height="100%" style="display: none; position: absolute; top: 0; left: 0; z-index: 1;"></canvas>
    </div>
    <button id="left" style="position: fixed; width: 15%; height: 22%; z-index: 5;">◄</button>
    <button id="right" style="position: fixed; width: 15%; height: 22%; z-index: 5;">►</button>
    <button id="up" style="position: fixed; width: 50%; height: 10%; z-index: 5;">▲</button>
    <button id="down" style="position: fixed; width: 50%; height: 10%; z-index: 5;">▼</button>
    <script>
        function shuffle(array) {
            let currentIndex = array.length,  randomIndex;

            // While there remain elements to shuffle.
            while (currentIndex != 0) {

                // Pick a remaining element.
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                array[randomIndex], array[currentIndex]];
            }

            return array;
        }

        function start() {
            document.getElementById('configure-btn').disabled = true;
            document.getElementById('generate-maze-btn').disabled = true;
            document.getElementById('configure-menu').style.display = 'none';

            //TODO FLASHLIGHT
            //TODO DIFFERENT ALGOS
            const tileSize = 25;
            const coinAmount = Math.round(Math.random() * 3) + 3;
            let width = 0;
            let height = 0;
    
            const canvas = document.getElementById("maze");
            const context = canvas.getContext("2d");
            const overlay = document.getElementById("maze-overlay");
            const ctxOverlay = overlay.getContext("2d");
            
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);

            let upPressed = false;
            let rightPressed = false;
            let downPressed = false;
            let leftPressed = false;
            setup_listeners();

            canvas.width = width * tileSize;
            canvas.height = height * tileSize;
            overlay.width = width * tileSize;
            overlay.height = height * tileSize;
            
            let player = new Player(0.03 * parseFloat(document.getElementById('speed').value));
            let exit = null;
            let grid = [];
            let cells = [];
            let coins = [];
            /*        FILL GRID        */
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    var cell = new Cell(x, y);
                    if (x > 0) {
                        let neighbour = grid[index(x-1,y)];
                        neighbour.neighbours[1] = cell;
                        cell.neighbours[3] = neighbour;
                    }
                    if (y > 0) {
                        let neighbour = grid[index(x,y-1)];
                        neighbour.neighbours[2] = cell;
                        cell.neighbours[0] = neighbour;
                    }
                    grid.push(cell);
                    cells.push(cell);
                }
            }

            if (document.getElementById('coins').checked) {
                shuffle(cells);
                for (let i = 0; i < coinAmount; i++) {
                    /**** SPAWN COINS ****/
                    let coin = new Coin();
                    coin.cell = cells[i];
                    cells[i].coin = coin;
                    coins.push(coin);
                }
            }

            /******* GENERATE MAZE *******/
            shuffle(cells);
            cells[0].visited = true;
            cells = cells.filter((cell) => {return !cell.visited});
            while (cells.length > 0) {
                
                let current_cell = cells[0];
                let new_path = [current_cell];
                while (current_cell && !current_cell.visited) {
                    current_cell.visited = true;
                    
                    let next = current_cell.getRandomNeighbourNotInPath(new_path);
                    if (next) {
                        new_path.push(next);
                    }
                    current_cell = next;
                }
                cells = cells.filter((cell) => {return !cell.visited});
            }


            /****** MAIN LOOP ******/
            let draw_queue = [];
            /* add all cells and the player to the draw queue so they get drawn the first iteration */
            for (let i = 0; i < grid.length; i++) {
                draw_queue.push(grid[i]);
            }
            draw_queue.push(player);

            // TODO MAIN LOOP
            let startTime = Date.now();
            player.last_loop = startTime;
            function main_loop() {
                update_timer();

                let directions = [upPressed, rightPressed, downPressed, leftPressed];
                if (directions.includes(true)) {
                    player.occupiesCells().forEach((cell) => {draw_queue.push(cell)});
                    player.move(directions);
                    
                    coins = coins.filter((coin) => {
                        if (coin.intersects(player)) {
                            coin.cell.coin = null;
                            draw_queue.push(coin.cell);
                            return false;
                        }
                        return true;
                    });

                    draw_queue.push(player);
                }
                if (!exit && coins.length == 0) {
                    exit = new Exit();
                    exit.initialize();
                    draw_queue.push(exit);
                }

                /* redraw all items in draw_queue */
                while (draw_queue.length > 0) {
                    draw_queue.shift().draw();
                } 

                player.last_loop = Date.now();

                if (!exit || !exit.intersects(player)) {
                    setTimeout(main_loop, 100);
                } else {
                    document.getElementById('fireworks').style.display = 'block';
                    startFireworks();
                }
            }
            main_loop();


            /*
            ==============================================
            Objects and object methods below
            ==============================================
            */


            function index(x, y) {
                return y * height + x;
            }

            function Cell(x, y) {
                this.self = this;
                this.x = x;
                this.y = y;
                this.visited = false;
                this.parent = null;
                this.neighbours = [null, null, null, null];
                this.walls = [true, true, true, true];
                this.coin = null;

                this.hasUnvisitedNeighbour = function() {
                    for (let i = 0; i < this.neighbours.length; i++) {
                        let n = this.neighbours[i];
                        if (n && !n.visited) return true;
                    }
                    return false;
                }

                this.getRandomUnvisitedNeighbour = function() {
                    if (!this.hasUnvisitedNeighbour()) {
                        return null;
                    }

                    var possible_neighbours = [];

                    for (let i = 0; i < this.neighbours.length; i++) {
                        let n = this.neighbours[i];
                        if (n && !n.visited) possible_neighbours.push(n);
                    }

                    let random = Math.round(Math.random() * (possible_neighbours.length - 1));
                    let chosen = possible_neighbours[random];

                    for (let i = 0; i < 4; i++) {
                        if (this.neighbours[i] === chosen) {
                            this.walls[i] = false;
                            chosen.walls[(i+2)%4] = false;
                        }
                    }

                    return chosen;
                }

                this.getRandomNeighbourNotInPath = function(path) {
                    var possible_neighbours = [];

                    for (let i = 0; i < this.neighbours.length; i++) {
                        let n = this.neighbours[i];
                        if (n && !path.includes(n)) possible_neighbours.push(n);
                    }

                    if (possible_neighbours.length == 0) return this.parent.getRandomNeighbourNotInPath(path);

                    let random = Math.round(Math.random() * (possible_neighbours.length - 1));
                    let chosen = possible_neighbours[random];

                    for (let i = 0; i < 4; i++) {
                        if (this.neighbours[i] === chosen) {
                            this.walls[i] = false;
                            chosen.walls[(i+2)%4] = false;
                        }
                    }

                    chosen.parent = this;

                    return chosen;
                }

                this.draw = function() {
                    context.fillStyle = "rgb(81, 66, 83)";
                    context.fillRect(this.x * tileSize, this.y * tileSize, tileSize, tileSize);

                    context.fillStyle = "#000000"
                    if (this.walls[0]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize);
                        context.stroke();
                    }
                    if (this.walls[1]) {
                        context.moveTo(this.x * tileSize + tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }
                    if (this.walls[2]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize + tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }
                    if (this.walls[3]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }

                    if (this.coin) this.coin.draw();
                }
            
            }   
        
            function Coin() {
                this.cell = null;
                this.draw = function() {
                    let x = this.cell.x * tileSize + Math.round((tileSize - 5) / 2);
                    let y = this.cell.y * tileSize + Math.round((tileSize - 9) / 2);

                    context.fillStyle = "#FFD300";
                    context.fillRect(x,y+2,5,5);
                    context.fillRect(x+1,y,3,9);
                }
                this.intersects = function(player) {
                    /* Used to test whether something (mainly player) intersects this object */
                    let x = this.cell.x * tileSize + Math.round((tileSize - 5) / 2);
                    let y = this.cell.y * tileSize + Math.round((tileSize - 9) / 2);

                    return boxIntersect(x,y,9,5,player.x,player.y,player.height,player.width);
                }
            }

            function Player(spd) {
                this.x = 9.0;
                this.y = Math.floor(height/2)*tileSize+9.0;
                this.speed = spd;
                this.last_loop = Date.now();
                this.width = 7;
                this.height = 7;
                this.draw = function() {
                    let occupiedCells = this.occupiesCells();
                    for (let i = 0; i < occupiedCells.length; i++) {
                        occupiedCells[i].draw();
                    }

                    context.fillStyle = "#FF0000";
                    context.fillRect(Math.round(this.x), Math.round(this.y), this.width, this.height);

                    if (document.getElementById('flashlight').checked) 
                        drawLight(ctxOverlay, Math.round(this.x+3), Math.round(this.y+3), 40);
                }
                this.occupiesCells = function() {
                    let cs = [];
                    let is = [index(Math.floor(this.x/tileSize), Math.floor(this.y/tileSize)), 
                              index(Math.floor((this.x+this.width)/tileSize), Math.floor(this.y/tileSize)), 
                              index(Math.floor(this.x/tileSize), Math.floor((this.y+this.height)/tileSize)), 
                              index(Math.floor((this.x+this.width)/tileSize), Math.floor((this.y+this.height)/tileSize))];
                    for (let x = 0; x < is.length; x++) {
                        let i = is[x];
                        if (!cs.includes(grid[i])) cs.push(grid[i]);
                    }
                    
                    return cs;
                }
                this.move = function(directions) {
                    /* This function moves the player based on a array[4] with the directions */
                    let now = Date.now();
                    let diff = now - this.last_loop;

                    if (directions[0]) {
                        this.y -= this.speed * diff;
                    }
                    if (directions[2]) {
                        this.y += this.speed * diff;
                    }
                    if (directions[3]) {
                        this.x -= this.speed * diff;
                    }
                    if (directions[1]) {
                        this.x += this.speed * diff;
                    }
                }
            }

            function Exit(x, y, side) {
                this.x = x;
                this.y = y;
                this.side = side;

                this.initialize = function() {
                    this.side = Math.floor(Math.random() * 3);
                    let h = Math.round(Math.random() * (width-1));
                    let v = Math.round(Math.random() * (height-1));
                    if (side === 0) {
                        this.x = h;
                        this.y = 0;
                    } else if (side === 2) {
                        this.x = h;
                        this.y = height-1;
                    } else {
                        this.x = width-1;
                        this.y = v;
                    }
                }
                this.draw = function() {
                    let px = this.x*tileSize;
                    let py = this.y*tileSize;

                    if (this.side === 0) {
                        py -= 13;
                    } else if (this.side === 2) {
                        py += 13;
                    } else {
                        px += 13;
                    }

                    drawEllipse(context, px, py, 25, 25);
                }
                this.intersects = function(player) {
                    /* Used to test whether something (mainly player) intersects with this object */
                    // if (this.side == 0) {
                    //     return boxIntersect(this.x*tileSize+3,0,13,19,player.x,player.y,player.height,player.width);
                    // } else if (this.side == 2) {
                    //     return boxIntersect(this.x*tileSize+3,this.y*tileSize+12,13,19,player.x,player.y,player.height,player.width);
                    // } else {
                    //     return boxIntersect(this.x*tileSize+12,this.y*tileSize+tileSize+3,19,13,player.x,player.y,player.height,player.width);
                    // }
                    
                    return player.occupiesCells().includes(grid[index(this.x,this.y)]);
                }
            }

            function update_timer() {
                var difference = Date.now() - startTime;
                var millis = difference%1000;
                var seconds = Math.floor(difference/1000)%60;
                var minutes = Math.floor(difference/60000)%60;
                var hours = Math.floor(difference/3600000);
                document.getElementById('timer').innerHTML = "" + hours + "H " + minutes + "m " + seconds + "." + millis + "s";
            }

            function setup_listeners() {
                var leftButton = document.getElementById("left");
                var rightButton = document.getElementById("right");
                var upButton = document.getElementById("up");
                var downButton = document.getElementById("down");

                leftButton.addEventListener("touchstart", function(ev) {
                    leftPressed = true;
                    ev.preventDefault();
                }, false);
                leftButton.addEventListener('mousedown', () => {
                    leftPressed = true;
                });
                leftButton.addEventListener("touchend", function(ev) {
                    leftPressed = false;
                    ev.preventDefault();
                }, false);
                leftButton.addEventListener('mouseup', () => {
                    leftPressed = false;
                });

                rightButton.addEventListener("touchstart", function(ev) {
                    rightPressed = true;
                    ev.preventDefault();
                }, false);
                rightButton.addEventListener('mousedown', () => {
                    rightPressed = true;
                });
                rightButton.addEventListener("touchend", function(ev) {
                    rightPressed = false;
                    ev.preventDefault();
                }, false);
                rightButton.addEventListener('mouseup', () => {
                    rightPressed = false;
                });

                upButton.addEventListener("touchstart", function(ev) {
                    upPressed = true;
                    ev.preventDefault();
                }, false);
                upButton.addEventListener('mousedown', () => {
                    upPressed = true;
                });
                upButton.addEventListener("touchend", function(ev) {
                    upPressed = false;
                    ev.preventDefault();
                }, false);
                upButton.addEventListener('mouseup', () => {
                    upPressed = false;
                });

                downButton.addEventListener("touchstart", function(ev) {
                    downPressed = true;
                    ev.preventDefault();
                }, false);
                downButton.addEventListener('mousedown', () => {
                    downPressed = true;
                });
                downButton.addEventListener("touchend", function(ev) {
                    downPressed = false;
                    ev.preventDefault();
                }, false);
                downButton.addEventListener('mouseup', () => {
                    downPressed = false;
                });

                document.addEventListener("keydown", (e) => {
                    switch (e.keyCode) {
                        case 38:
                        case 87: //w
                            upPressed = true;
                            break;
                        case 37:
                        case 65: //a
                            leftPressed = true;
                            break;
                        case 40:
                        case 83: //s
                            downPressed = true;
                            break;
                        case 39:
                        case 68: //d
                            rightPressed = true;
                            break;
    
                        default:
                            return; // Do nothing for the rest
                    };
                });
    
                document.addEventListener("keyup", (e) => {
                    switch (e.keyCode) {
                        case 38:
                        case 87: //w
                            upPressed = false;
                            break;
                        case 37:
                        case 65: //a
                            leftPressed = false;
                            break;
                        case 40:
                        case 83: //s
                            downPressed = false;
                            break;
                        case 39:
                        case 68: //d
                            rightPressed = false;
                            break;
    
                        default:
                            return; // Do nothing for the rest
                    };
                });
            }
            

            function boxIntersect(ax, ay, ah, aw, bx, by, bh, bw) {
                return Math.abs((ax + aw/2) - (bx + bw/2)) * 2 < (aw + bw) && 
                       Math.abs((ay + ah/2) - (by + bh/2)) * 2 < (ah + bh);
            }

            function drawEllipseByCenter(ctx, cx, cy, w, h, color) {
                drawEllipse(ctx, cx - w/2.0, cy - h/2.0, w, h);
            }

            function drawEllipse(ctx, x, y, w, h) {
                var kappa = .5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

                ctx.fillStyle = "rgb(250, 227, 152)";

                ctx.beginPath();
                ctx.moveTo(x, ym);
                ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                //ctx.closePath(); // not used correctly, see comments (use to close off open path)
                ctx.fill();
            }

            function drawLight(ctx, cx, cy, r) {
                ctx.fillStyle = "#000000";
                ctx.fillRect(0,0,overlay.width,overlay.height);

                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.clip();
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                ctx.restore();

                if (exit) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(centerExitX, centerExitY, 35, 0, 2 * Math.PI);
                    ctx.clip();
                    ctx.clearRect(0, 0, overlay.width, overlay.height);
                    ctx.restore();
                }
            }


            /*
            ==================================================
            Start of the fireworks code, this is not mine, I used the code provided by http://seowebsitedesigning.com/create-fireworks-effect-using-html5-canvas/
            I do not take the credit of writing this piece of code whatshowever!!!
            ==================================================
            */
            function startFireworks() {
                var screenWidth = window.innerWidth;
                var screenHeight = window.innerHeight;

                var minVx = -10;
                var deltaVx = 20;
                var minVy = 25
                var deltaVy = 15;
                var minParticleV = 5;
                var deltaParticleV = 5;

                var gravity = 1;

                var explosionRadius = 200;
                var bombRadius = 10;
                var explodingDuration = 100;
                var explosionDividerFactor = 10; // I couldn't find a better name. Got any?

                var nBombs = 1; // initial
                var percentChanceNewBomb = 5;

                // Color utils forked from http://andreasstorm.com/
                // (or someone who forked from there)

                function Color(min) {
                    min = min || 0;
                    this.r = colorValue(min);
                    this.g = colorValue(min);
                    this.b = colorValue(min);
                    this.style = createColorStyle(this.r, this.g, this.b);
                };

                function colorValue(min) {
                    return Math.floor(Math.random() * 255 + min);
                }

                function createColorStyle(r,g,b) {
                    return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)';
                }

                // A Bomb. Or firework.
                function Bomb(){
                    var self = this;
                    
                    self.radius = bombRadius;
                    self.previousRadius = bombRadius;
                    self.explodingDuration = explodingDuration;
                    self.hasExploded = false;
                    self.alive = true;
                    self.color = new Color();
                    
                    self.px = (window.innerWidth / 4) + (Math.random() * window.innerWidth / 2);
                    self.py = window.innerHeight;
                    
                    self.vx = minVx + Math.random() * deltaVx;
                    self.vy = (minVy + Math.random() * deltaVy) * -1; // because y grows downwards

                    self.duration = 

                    self.update = function(particlesVector){
                        if(self.hasExploded){
                        var deltaRadius = explosionRadius - self.radius;
                        self.previousRadius = self.radius;
                        self.radius += deltaRadius / explosionDividerFactor;
                        self.explodingDuration--;
                        if(self.explodingDuration == 0){
                            self.alive = false;
                        }
                        }
                        else{
                        self.vx += 0;
                        self.vy += gravity;
                        if(self.vy >= 0){ // invertion point
                            self.explode(particlesVector);
                        }

                        self.px += self.vx;
                        self.py += self.vy;
                        }
                    };

                    self.draw = function(ctx){
                        ctx.beginPath();
                        ctx.arc(self.px, self.py, self.previousRadius, 0, Math.PI * 2, false);
                        if(self.hasExploded){
                        }
                        else{
                        ctx.fillStyle = self.color.style;
                        ctx.lineWidth = 1;
                        ctx.fill();
                        }
                        
                    };
                    

                    self.explode = function(particlesVector){
                        self.hasExploded = true;
                        var e = 3 + Math.floor(Math.random() * 3);
                        for(var j = 0; j < e; j++){
                        var n = 10 + Math.floor(Math.random() * 21); // 10 - 30
                        var speed = minParticleV + Math.random() * deltaParticleV;
                        var deltaAngle = 2 * Math.PI / n;
                        var initialAngle = Math.random() * deltaAngle;
                        for(var i = 0; i < n; i++){
                            particlesVector.push(new Particle(self,  i * deltaAngle + initialAngle, speed));
                        }
                        }
                    };
                    
                    }

                    function Particle(parent, angle, speed){
                    var self = this;
                    self.px = parent.px;
                    self.py = parent.py;
                    self.vx = Math.cos(angle) * speed;
                    self.vy = Math.sin(angle) * speed;
                    self.color = parent.color;
                    self.duration = 40 + Math.floor(Math.random()*20);
                    self.alive = true;

                    self.update = function(){
                        self.vx += 0;
                        self.vy += gravity / 10;

                        self.px += self.vx;
                        self.py += self.vy;
                        self.radius = 3;

                        self.duration--;
                        if(self.duration <= 0){
                        self.alive = false;
                        }
                    };

                    self.draw = function(ctx){
                        ctx.beginPath();
                        ctx.arc(self.px, self.py, self.radius, 0, Math.PI * 2, false);
                        ctx.fillStyle = self.color.style;
                        ctx.lineWidth = 1;
                        ctx.fill();
                    };

                }

                function Controller(){
                    var self = this;
                    self.canvas = document.getElementById("fireworks");
                    self.canvas.width = screenWidth;
                    self.canvas.height = screenHeight;
                    self.ctx = self.canvas.getContext('2d');

                    function setSpeedParams(){
                        var heightReached = 0;
                        var vy = 0;

                        while(heightReached < screenHeight && vy >= 0){
                        vy += gravity;
                        heightReached += vy;
                        }

                        minVy = vy / 2;
                        deltaVy = vy - minVy;

                        vx = (1 / 4) * screenWidth / (vy / 2);
                        minVx = -vx;
                        deltaVx = 2*vx;
                    };

                    

                    self.resize = function(){
                        screenWidth = window.innerWidth;
                        screenHeight = window.innerHeight;
                        self.canvas.width = screenWidth;
                        self.canvas.height = screenHeight;
                        setSpeedParams();
                    };
                    self.resize();

                    window.onresize = self.resize;

                    self.init = function(){
                        self.readyBombs = [];
                        self.explodedBombs = [];
                        self.particles = [];

                        for(var i = 0; i < nBombs; i++){
                        self.readyBombs.push(new Bomb());
                        }
                    }

                    self.update = function(){
                        var aliveBombs = [];
                        while(self.explodedBombs.length > 0){
                        var bomb = self.explodedBombs.shift();
                        bomb.update();
                        if(bomb.alive){
                            aliveBombs.push(bomb);
                        }
                        }
                        self.explodedBombs = aliveBombs;

                        var notExplodedBombs = [];
                        while(self.readyBombs.length > 0){
                        var bomb = self.readyBombs.shift();
                        bomb.update(self.particles);
                        if(bomb.hasExploded){
                            self.explodedBombs.push(bomb);
                        }
                        else{
                            notExplodedBombs.push(bomb);
                        }
                        }
                        self.readyBombs = notExplodedBombs;

                        var aliveParticles = [];
                        while(self.particles.length > 0){
                        var particle = self.particles.shift();
                        particle.update();
                        if(particle.alive){
                            aliveParticles.push(particle);
                        }
                        }
                        self.particles = aliveParticles;
                    }

                    self.draw = function(){
                        self.ctx.beginPath();
                        self.ctx.fillStyle='rgba(0, 0, 0, 0.1)'; // Ghostly effect
                        self.ctx.fillRect(0, 0, self.canvas.width, self.canvas.height);
                        
                        
                        
                        for(var i = 0; i < self.readyBombs.length; i++){
                        self.readyBombs[i].draw(self.ctx);
                        }

                        for(var i = 0; i < self.explodedBombs.length; i++){
                        self.explodedBombs[i].draw(self.ctx);
                        }

                        for(var i = 0; i < self.particles.length; i++){
                        self.particles[i].draw(self.ctx);
                        }

                    }

                    self.animation = function(){
                        self.update();
                        self.draw();
                        
                    if(Math.random() * 100 < percentChanceNewBomb) {
                        self.readyBombs.push(new Bomb());
                    }
                        
                            
                        requestAnimationFrame(self.animation);
                    }
                }

                var controller = new Controller();
                controller.init();
                requestAnimationFrame(controller.animation);
            }
        } 
    </script>
</body>
