<!DOCTYPE html>
<head>
    <title>A maze game</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" rel="stylesheet"> 
    <style>
        #up, #down, #left, #right {
            display: none;
            background-color: rgba(32, 32, 32, 0.76);
            color: white;
        }
        #up {
            left: 50%;
            top: 100%;
            transform: translate3d(-50%, -320%, 0);
        }
        #down {
            left: 50%;
            top: 100%;
            transform: translate3d(-50%, -200%, 0);
        }
        #left {
            left: 25%;
            top: 100%;
            transform: translate3d(-110%, -128px, 0);
        }
        #right {
            left: 75%;
            top: 100%;
            transform: translate3d(10%, -128px, 0);
        }
        @media only screen and (max-width: 1500px) {
            #up, #down, #left, #right {
                display: block;
            }
        }
    </style>
</head>
<body style="background-color: black;">
    <div style="text-align: center;">
        <h1 style="color: lightgray;">THE MAZE GAME</h1>
        <div id="flexbox" style="display: flexbox; justify-content: space-evenly; margin-left: auto; margin-right: auto;">
            <button id="easy" onclick="selectEasy()">Easy</button>
            <button id="medium" onclick="selectMedium()">Medium</button>
            <button id="hard" onclick="selectHard()">Hard</button>
            <button id="monster" onclick="selectMonster()">Monster Difficulty*</button>
            <input type="checkbox" id="otherAlgo" name="otherAlgo" value="otherAlgo">
                <label for="otherAlgo" style="color: lightgray;">different maze gen algorithm</label><br>
        </div>
        <p style="color: lightgray;">*<i>Warning, this mode is extremely dangerous, and takes a long time to load, please be patient!</i></p>
        <br>
        <hr>
        <br><br><br>
        <p id="timer" style="position: relative; width: 50%; margin-left: 25%; margin-right: 25%; font-family: 'Roboto', sans-serif; color: lightgray; text-align: center;">0H 0m 0s</p>
        <div id="canvaswrapper" width="150" height="100" style="position: relative; left: 40%;">
            <canvas id="maze" width="150" height="100" style="position: absolute; top: 0px; left: 0px; z-index: 2;"></canvas>
            <canvas id="maze-overlay" width="150" height="100" style="display: none; position: absolute; top: 0px; left: 0px; z-index: 3;"></canvas>
        </div>
        <canvas id="fireworks" width="100%" height="100%" style="display: none; position: absolute; top: 0; left: 0; z-index: 1;"></canvas>
    </div>
    <button id="left" style="position: fixed; width: 50px; height: 88px; z-index: 5;">◄</button>
    <button id="right" style="position: fixed; width: 50px; height: 88px; z-index: 5;">►</button>
    <button id="up" style="position: fixed; width: 50%; height: 40px; z-index: 5;">▲</button>
    <button id="down" style="position: fixed; width: 50%; height: 40px; z-index: 5;">▼</button>
    <script>
        var difficulty = undefined;
        var differentAlgo = false;

        function selectEasy() {
            console.log("easy");
            difficulty = "easy";
            if ($('#otherAlgo').prop("checked") === true) {
                differentAlgo = true;
            }
            $('#otherAlgo').attr("disabled", true);
            $('#easy').attr("disabled", true);
            $('#medium').attr("disabled", true);
            $('#hard').attr("disabled", true);
            $('#monster').attr("disabled", true);
            start();
        }

        function selectMedium() {
            console.log("medium");
            difficulty = "medium";
            if ($('#otherAlgo').prop("checked") === true) {
                differentAlgo = true;
            }
            $('#otherAlgo').attr("disabled", true);
            $('#easy').attr("disabled", true);
            $('#medium').attr("disabled", true);
            $('#hard').attr("disabled", true);
            $('#monster').attr("disabled", true);
            start();
        }

        function selectHard() {
            console.log("hard");
            difficulty = "hard";
            if ($('#otherAlgo').prop("checked") === true) {
                differentAlgo = true;
            }
            $('#otherAlgo').attr("disabled", true);
            $('#easy').attr("disabled", true);
            $('#medium').attr("disabled", true);
            $('#hard').attr("disabled", true);
            $('#monster').attr("disabled", true);
            $('#maze-overlay').css("display", "block");
            start();
        }

        function selectMonster() {
            console.log("Monster Difficult");
            difficulty = "monster";
            if ($('#otherAlgo').prop("checked") === true) {
                differentAlgo = true;
            }
            $('#otherAlgo').attr("disabled", true);
            $('#easy').attr("disabled", true);
            $('#medium').attr("disabled", true);
            $('#hard').attr("disabled", true);
            $('#monster').attr("disabled", true);
            $('#maze-overlay').css("display", "block");
            start();
        }

        function start() {
            const tileSize = 25;
            var width = 15;
            var height = 15;
            if (difficulty === "easy") {
                var width = 30;
                var height = 25;
            }
            if (difficulty === "monster") {
                var width = 40;
                var height = 35;
            }
            var sameDirInRow = 0;
            var previousDir = -1;
            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") {
                var coinAmount = Math.round(Math.random() * 6); // these coins will spawn randomly which you need to get in order to be able to see the exit.
                while (coinAmount < 3) {
                    //we do not want less than 3 coins
                    coinAmount = Math.round(Math.random() * 6);
                }
            }
            const canvas = document.getElementById("maze");
            const context = canvas.getContext("2d");
            const overlay = document.getElementById("maze-overlay");
            const ctxOverlay = overlay.getContext("2d");
            canvas.width = width * tileSize;
            canvas.height = height * tileSize;
            overlay.width = width * tileSize;
            overlay.height = height * tileSize;

            if (screen.width-canvas.width > 0) {
                $('#canvaswrapper').css("left", (screen.width-canvas.width)/2);
            } else {
                $('#canvaswrapper').css("left", 0);
            }
            
            let grid = [];
            let cells = [];

            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    var cell = new Cell(x, y);
                    //debugger;
                    grid.push(cell);
                    if (differentAlgo) {
                        cells.push(cell);
                    }
                }
            }

            if (!differentAlgo) { 
                var current = grid[0];
                while (current) {
                    current.visited = true;
                    if (current.hasUnvisitedNeighbour()) {
                        var next = current.getRandomUnvisitedNeighbour();
                        current = next;
                    } else {
                        current = current.parent;
                    }
                } 
            } else {
                var random = Math.round(Math.random() * (cells.length-1));
                var current = cells[random];
                current.visited = true;
                cells.splice(random, 1);
                console.log(grid.length);
                while (cells.length > 0) {
                    random = Math.round(Math.random() * (cells.length-1));
                    //console.log(random);
                    current = cells[random];
                    
                    if (current.canConnectToMaze()) {
                        current.connectToMaze();
                        cells.splice(random, 1);
                        console.log("connected cell");
                    }
                }
            }

            grid[0].walls[3] = false;

            for (let i = 0; i < grid.length; i++) {
                grid[i].show();
            }
            
            
            context.fillStyle = "#000000";
            context.moveTo(1,26);
            context.lineTo(1, height * tileSize - 1);
            context.stroke(); // left
            
            context.moveTo(1,1);
            context.lineTo(width * tileSize - 1, 1);
            context.stroke(); // top

            context.moveTo(width * tileSize - 1, height * tileSize - 1);
            context.lineTo(width * tileSize - 1, 1);
            context.stroke(); // right

            context.moveTo(width * tileSize - 1, height * tileSize - 1);
            context.lineTo(1, height * tileSize - 1);
            context.stroke(); // bottom
            
            

            /*
            ==============================================
            Objects and object methods below
            ==============================================
            */


            function index(x, y) {
                //console.log(x + " " + y + " " + (x * width + y));
                return x * height + y;
            }

            function Cell(x, y) {
                this.self = this;
                this.x = x;
                this.y = y;
                this.visited = false;
                this.parent = null;
                this.walls = [true, true, true, true]; //top right bottom left

                this.hasUnvisitedNeighbour = function() {
                    if (this.y >= 1) {
                        var top = grid[index(this.x, this.y - 1)];
                        if (!top.visited) {
                            return true;
                        }
                    }
                    if (this.x <= width - 2) {
                        var right = grid[index(this.x + 1, this.y)];
                        if (!right.visited) {
                            return true;
                        }
                    }
                    if (this.y <= height - 2) {
                        var bottom = grid[index(this.x, this.y + 1)];
                        if (!bottom.visited) {
                            return true;
                        }
                    }
                    if (this.x >= 1) {
                        var left = grid[index(this.x - 1, this.y)];
                        if (!left.visited) {
                            return true;
                        }
                    }
                }

                this.getRandomUnvisitedNeighbour = function() {
                    if (!this.hasUnvisitedNeighbour) {
                        return null;
                    }

                    var neighbours = [];

                    var top = null;
                    var right = null;
                    var bottom = null;
                    var left = null;
                    var possibleNeigh = 0;
                    if (this.y >= 1) {
                        var top = grid[index(this.x, this.y - 1)];
                        possibleNeigh++;
                    }
                    if (this.x <= width - 2) {
                        var right = grid[index(this.x + 1, this.y)];
                        possibleNeigh++;
                    }
                    if (this.y <= height - 2) {
                        var bottom = grid[index(this.x, this.y + 1)];
                        possibleNeigh++;
                    }
                    if (this.x >= 1) {
                        var left = grid[index(this.x - 1, this.y)];
                        possibleNeigh++;
                    }
                    neighbours.push(top);
                    neighbours.push(right);
                    neighbours.push(bottom);
                    neighbours.push(left);

                    var chosen = null;
                    let random;
                    while (!chosen || chosen.visited || (random === previousDir && sameDirInRow > 5 && possibleNeigh > 1)) {
                        random = Math.round(Math.random() * (neighbours.length - 1))
                        chosen = neighbours[random];
                    }

                    if (random === previousDir) {
                        sameDirInRow++;
                    } else {
                        sameDirInRow = 0;
                        previousDir = random;
                    }
                    this.walls[random] = false;
                    random += 2;
                    if (random > 3) {
                        random -= 4;
                    }
                    chosen.walls[random] = false;
                    chosen.parent = this.self;

                    return chosen;
                }

                this.canConnectToMaze = function() {
                    if (this.y >= 1) {
                        var top = grid[index(this.x, this.y - 1)];
                        if (top.visited) {
                            return true;
                        }
                    }
                    if (this.x <= width - 2) {
                        var right = grid[index(this.x + 1, this.y)];
                        if (right.visited) {
                            return true;
                        }
                    }
                    if (this.y <= height - 2) {
                        var bottom = grid[index(this.x, this.y + 1)];
                        if (bottom.visited) {
                            return true;
                        }
                    }
                    if (this.x >= 1) {
                        var left = grid[index(this.x - 1, this.y)];
                        if (left.visited) {
                            return true;
                        }
                    }
                    return false;
                }

                this.connectToMaze = function() {
                    this.visited = true;

                    let connectableCells = [];

                    if (this.y >= 1) {
                        var top = grid[index(this.x, this.y - 1)];
                        if (top.visited) {
                            connectableCells.push({cell: top, wall: 0, otherWall: 2});
                        }
                    }
                    if (this.x <= width - 2) {
                        var right = grid[index(this.x + 1, this.y)];
                        if (right.visited) {
                            connectableCells.push({cell: right, wall: 1, otherWall: 3});
                        }
                    }
                    if (this.y <= height - 2) {
                        var bottom = grid[index(this.x, this.y + 1)];
                        if (bottom.visited) {
                            connectableCells.push({cell: bottom, wall: 2, otherWall: 0});
                        }
                    }
                    if (this.x >= 1) {
                        var left = grid[index(this.x - 1, this.y)];
                        if (left.visited) {
                            connectableCells.push({cell: left, wall: 3, otherWall: 1});
                        }
                    }

                    var choice = connectableCells[Math.round(Math.random() * (connectableCells.length - 1))];
                    var chosen = choice.cell;

                    this.walls[choice.wall] = false;
                    chosen.walls[choice.otherWall] = false;
                    this.parent = chosen;
                }

                this.show = function() {
                    context.fillStyle = "#192841";
                    context.fillRect(this.x * tileSize, this.y * tileSize, tileSize, tileSize);

                    context.fillStyle = "#000000"
                    if (this.walls[0]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize);
                        context.stroke();
                    }
                    if (this.walls[1]) {
                        context.moveTo(this.x * tileSize + tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }
                    if (this.walls[2]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize + tileSize);
                        context.lineTo(this.x * tileSize + tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }
                    if (this.walls[3]) {
                        context.moveTo(this.x * tileSize, this.y * tileSize);
                        context.lineTo(this.x * tileSize, this.y * tileSize + tileSize);
                        context.stroke();
                    }
                }
            }   
        
            var upPressed = false;
            var downPressed = false;
            var leftPressed = false;
            var rightPressed = false;
            var leftButton = document.getElementById("left");
            var rightButton = document.getElementById("right");
            var upButton = document.getElementById("up");
            var downButton = document.getElementById("down");

            leftButton.addEventListener("touchstart", function(ev) {
                leftPressed = true;
            }, false);
            $('#left').mousedown(() => {
                leftPressed = true;
            });
            leftButton.addEventListener("touchstart", function(ev) {
                leftPressed = false;
            }, false);
            $('#left').mouseup(() => {
                leftPressed = false;
            });

            rightButton.addEventListener("touchstart", function(ev) {
                rightPressed = true;
            }, false);
            $('#right').mousedown(() => {
                rightPressed = true;
            });
            rightButton.addEventListener("touchstart", function(ev) {
                rightPressed = false;
            }, false);
            $('#right').mouseup(() => {
                rightPressed = false;
            });

            upButton.addEventListener("touchstart", function(ev) {
                upPressed = true;
            }, false);
            $('#up').mousedown(() => {
                upPressed = true;
            });
            upButton.addEventListener("touchstart", function(ev) {
                upPressed = false;
            }, false);
            $('#up').mouseup(() => {
                upPressed = false;
            });

            downButton.addEventListener("touchstart", function(ev) {
                downPressed = true;
            }, false);
            $('#down').mousedown(() => {
                downPressed = true;
            });
            downButton.addEventListener("touchstart", function(ev) {
                downPressed = false;
            }, false);
            $('#down').mouseup(() => {
                downPressed = false;
            });
            context.fillStyle = "#FF0000";
            context.fillRect(9, 9, 7, 7);
            var startTime = Date.now();
            var x = 9;
            var y = 9;
            var oldx = x;
            var oldy = y;
            var winX = -1;
            var winY = -1;
            var centerExitX = -1;
            var centerExitY = 1;
            var noExit = true;
            var coins = [];
            var inExit = false;

            document.addEventListener("keydown", (e) => {
                switch (e.keyCode) {
                    case 87: //w
                        upPressed = true;
                        break;
                    case 65: //a
                        leftPressed = true;
                        break;
                    case 83: //s
                        downPressed = true;
                        break;
                    case 68: //d
                        rightPressed = true;
                        break;

                    default:
                        return; // Do nothing for the rest
                };
            });

            document.addEventListener("keyup", (e) => {
                switch (e.keyCode) {
                    case 87: //w
                        upPressed = false;
                        break;
                    case 65: //a
                        leftPressed = false;
                        break;
                    case 83: //s
                        downPressed = false;
                        break;
                    case 68: //d
                        rightPressed = false;
                        break;

                    default:
                        return; // Do nothing for the rest
                };
            });

            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") { addCoins(); }
            else { addExit(); noExit = false; }
            
            update();
            var req;

            function update() {
                var difference = Date.now() - startTime;
                var millis = difference%1000;
                var seconds = Math.floor(difference/1000)%60;
                var minutes = Math.floor(difference/60000)%60;
                var hours = Math.floor(difference/3600000);
                $('#timer').text(hours + "H " + minutes + "m " + seconds + "." + millis + "s");

                setTimeout(function() {
                    oldx = x;
                    oldy = y;
                    var gotACoin = false;

                    var surroundings = context.getImageData(x-1, y-1,9,9).data;

                    var allowedLeft = function() {
                        let ioffset = 1;
                        let length = 8;
                        if (upPressed) {
                            ioffset = 0;
                            length += 1;
                        }
                        if (downPressed) {
                            length += 1;
                        }
                        if (upPressed && downPressed) {
                            ioffset = 1;
                            length = 8;
                        }
                        for (let i = ioffset; i < length; i++) {
                            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") {
                                if (!rightPressed && surroundings[i * 36] == 255 && surroundings[i*36+1] == 211 && surroundings[i*36+2] == 0) {
                                    gotACoin = true;
                                }
                            }
                            if (!rightPressed && surroundings[i * 36] == 101 && surroundings[i*36+1] == 147 && surroundings[i*36+2] == 245) {
                                inExit = true;
                            }
                            if (surroundings[i * 36] < 5 && surroundings[i*36+1] < 5 && surroundings[i*36+2] < 5) {
                                return false;
                            }
                        }
                        return true;
                    }
                    var allowedRight = function() {
                        let ioffset = 1;
                        let length = 8;
                        if (upPressed) {
                            ioffset = 0;
                            length += 1;
                        }
                        if (downPressed) {
                            length += 1;
                        }
                        if (upPressed && downPressed) {
                            ioffset = 1;
                            length = 8;
                        }
                        for (let i = ioffset; i < length; i++) {
                            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") {
                                if (!leftPressed && surroundings[i * 36 + 32] == 255 && surroundings[i*36+33] == 211 && surroundings[i*36+34] == 0) {
                                    gotACoin = true;
                                }
                            }
                            if (!leftPressed && surroundings[i * 36 + 32] == 101 && surroundings[i*36+33] == 147 && surroundings[i*36+34] == 245) {
                                inExit = true;
                            }
                            if (surroundings[i * 36 + 32] < 5 && surroundings[i*36+33] < 5 && surroundings[i*36+34] < 5) {
                                return false;
                            }
                        }
                        return true;
                    }
                    var allowedDown = function() {
                        let ioffset = 1;
                        let length = 8;
                        if (leftPressed) {
                            ioffset = 0;
                            length += 1;
                        }
                        if (rightPressed) {
                            length += 1;
                        }
                        if (leftPressed && rightPressed) {
                            ioffset = 1;
                            length = 8;
                        }
                        var offset = 8*36;
                        for (let i = ioffset; i < length; i++) {
                            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") {
                                if (!upPressed && surroundings[i * 4 + offset] == 255 && surroundings[i*4+1 + offset] == 211 && surroundings[i*4+2 + offset] == 0) {
                                    gotACoin = true;
                                }
                            }
                            if (!upPressed && surroundings[i * 4 + offset] == 101 && surroundings[i*4+1 + offset] == 147 && surroundings[i*4+2 + offset] == 245) {
                                inExit = true;
                            }
                            if (surroundings[i * 4 + offset] < 5 && surroundings[i*4+1 + offset] < 5 && surroundings[i*4+2 + offset] < 5) {
                                return false;
                            }
                        }
                        return true;
                    }
                    var allowedUp = function() {
                        let ioffset = 1;
                        let length = 8;
                        if (leftPressed) {
                            ioffset = 0;
                            length += 1;
                        }
                        if (rightPressed) {
                            length += 1;
                        }
                        if (leftPressed && rightPressed) {
                            ioffset = 1;
                            length = 8;
                        }
                        for (let i = ioffset; i < length; i++) {
                            if (difficulty === "medium" || difficulty === "hard" || difficulty === "monster") {
                                if (!downPressed && surroundings[i * 4] == 255 && surroundings[i*4+1] == 211 && surroundings[i*4+2] == 0) {
                                    gotACoin = true;
                                }
                            }
                            if (!downPressed && surroundings[i * 4] == 101 && surroundings[i*4+1] == 147 && surroundings[i*4+2] == 245) {
                                inExit = true;
                            }
                            if (surroundings[i * 4] < 5 && surroundings[i*4+1] < 5 && surroundings[i*4+2] < 5) {
                                return false;
                            }
                        }
                        return true;
                    }

                    if (upPressed && allowedUp()) {
                        if (y > 0) {
                            y -= 1;
                        }
                    }
                    if (leftPressed && allowedLeft()) {
                        if (x > 0) {
                            x -= 1;
                        }
                    }
                    if (downPressed && allowedDown()) {
                        if (y < height * tileSize - 7) {
                            y += 1; 
                        }
                    }
                    if (rightPressed && allowedRight()) {
                        if (x < width * tileSize - 7) {
                            x += 1; 
                        }
                    }

                    if (gotACoin && (difficulty === "medium" || difficulty === "hard" || difficulty === "monster")) {
                        // let gottenCoins = [];
                        // for (let i = 0; i < coins.length; i++) {
                        //     let coin = coins[i];
                        //     if (x-coin.x < 0 && (x+8)-coin.x > 0 && y-coin.y < 0 && (y+8)-coin.y > 0) {
                        //         console.log("gotten coin");
                        //         gottenCoins.push(i);
                        //         gottenCoin(i);
                        //     }
                        // }
                        // for (let i = gottenCoins.length - 1; i >= 0; i--) {
                        //     coins.splice(gottenCoins[i], 1);
                        //     console.log(coins.length);
                        // }
                        // if (coins.length < 1 && noExit) {
                        //     //debugger;
                        //     addExit();
                        //     console.log("added exit");
                        //     noExit = false;
                        // }
                        gottenCoin(x, y);
                    }

                    redrawPlayer(oldx, oldy, x, y);

                    if (inExit || (winX > -1 && winY > -1 && x >= (winX+0.25)*tileSize && x <= (winX+0.75) * tileSize && y >= (winY+0.25)*tileSize && y <= (winY+0.75) * tileSize)) {
                        console.log("you've won!");
                        cancelAnimationFrame(req);
                        $('#fireworks').css("display", "block");
                        startFireworks();
                    } else {
                        req = requestAnimationFrame(update);
                    }
                }, 1000/200);
            }

            function redrawGrid() {
                for (let i = 0; i< grid.length; i++) {
                    grid[i].show();
                }

                for (let i = 0; i < coins.length; i++) {
                    drawEllipseByCenter(context, coins[i].x, coins[i].y, 5, 9);
                }
            }

            function redrawPlayer(oldX, oldY, newX, newY) {
                context.fillStyle = "#192841";
                context.fillRect(oldX, oldY, 7, 7);
                context.fillStyle = "#FF0000";
                context.fillRect(newX, newY, 7, 7);

                if (difficulty === "hard") {
                    drawLight(ctxOverlay, newX - 3, newY - 3, 40);
                }
                if (difficulty === "monster") {
                    drawLight(ctxOverlay, newX - 3, newY - 3, 28);
                }
            }

            function gottenCoin(x, y) {
                //first map x,y to the normal tileSize;
                normalizedX = Math.floor(x/tileSize);
                normalizedY = Math.floor(y/tileSize);
                console.log("location: " + normalizedX + ", " + normalizedY);

                var indicesToSplice = [];
                for (let i = 0; i < coins.length; i++) {
                    if (coins[i].tileX === normalizedX && coins[i].tileY === normalizedY) {
                        grid[index(coins[i].tileX, coins[i].tileY)].show();
                        indicesToSplice.push(i);
                    }
                }

                for (let i = indicesToSplice.length - 1; i >= 0; i--) {
                    coins.splice(indicesToSplice[i], 1);
                    console.log(coins.length);
                }

                if (coins.length < 1 && noExit) {
                    //debugger;
                    addExit();
                    console.log("added exit");
                    noExit = false;
                }
            }

            function addCoins() {
                let gridSize = grid.length - 1;
                let halfTile = Math.floor(tileSize/2);
                for (let i = 0; i <= coinAmount; i++) {
                    let choice = Math.round(Math.random() * gridSize);
                    let tileOfCoin = grid[choice];
                    let coinX = tileOfCoin.x*tileSize+halfTile;
                    let coinY = tileOfCoin.y*tileSize+halfTile;
                    drawCoin(coinX, coinY);
                    //drawEllipseByCenter(context, coinX, coinY, 5, 9);

                    coins.push({x: coinX, y: coinY, tileX: tileOfCoin.x, tileY: tileOfCoin.y});
                    console.log("added coin on: " + coinX + ", " + coinY);
                }
                console.log("number of coins: " + coins.length);
            }

            function addExit() {
                //choose the ending tile
                //first choose the side 0 top, 1 right, 2 bottom
                var side = Math.round(Math.random() * 2);
                var place = 0;
                
                //then decide the place
                if (side === 0) { // if top we dont want to have it near the start
                    place = 10 + Math.round(Math.random() * (width - 11));
                    winX = place;
                    winY = 0;
                    grid[index(place, 0)].walls[side] = false;
                } else if (side === 1) {
                    place = Math.round(Math.random() * (height - 1));
                    winX = width - 1;
                    winY = place;
                    grid[index(width - 1, place)].walls[side] = false;
                } else {
                    place = Math.round(Math.random() * (width - 1));
                    winX = place;
                    winY = height - 1;
                    grid[index(place, height - 1)].walls[side] = false;
                }

                if (side === 0) {
                    context.fillStyle = "#192841";
                    context.moveTo(1,1);
                    context.lineTo(width * tileSize - 1, 1);
                    context.stroke();

                    context.fillStyle = "#000000";
                    context.moveTo(1,1);
                    context.lineTo(place * tileSize, 1);
                    context.stroke();
                    context.moveTo((place + 1) * tileSize,1);
                    context.lineTo(width * tileSize - 1, 1);
                    context.stroke(); //top

                    drawEllipseByCenter(context, winX*tileSize+13, 0, 25, 25, "#6593F5");

                    centerExitX = winX*tileSize + 13;
                    centerExitY = 0;
                }
                if (side === 1) {
                    context.fillStyle = "#192841";
                    context.moveTo(width * tileSize - 1, height * tileSize - 1);
                    context.lineTo(width * tileSize - 1, 1);
                    context.stroke();
                    
                    context.fillStyle = "#000000";
                    context.moveTo(width * tileSize - 1, height * tileSize - 1);
                    context.lineTo(width * tileSize - 1, (place + 1) * tileSize);
                    context.stroke();
                    context.moveTo(width * tileSize - 1, place * tileSize);
                    context.lineTo(width * tileSize - 1, 1);
                    context.stroke(); // right

                    drawEllipseByCenter(context, (winX+1)*tileSize, winY*tileSize+13, 25, 25, "#6593F5");

                    centerExitX = width*tileSize;
                    centerExitY = winY*tileSize + 13;
                }
                if (side === 2) {
                    context.fillStyle = "#192841";
                    context.moveTo(width * tileSize - 1, height * tileSize - 1);
                    context.lineTo(1, height * tileSize - 1);
                    context.stroke();

                    context.fillStyle = "#000000";
                    context.moveTo(width * tileSize - 1, height * tileSize - 1);
                    context.lineTo((place + 1) * tileSize, height * tileSize - 1);
                    context.stroke();
                    context.moveTo(place * tileSize,height * tileSize - 1);
                    context.lineTo(1, height * tileSize - 1);
                    context.stroke(); // bottom

                    drawEllipseByCenter(context, winX*tileSize+13, (winY+1)*tileSize, 25, 25, "#6593F5");

                    centerExitX = winX*tileSize + 13;
                    centerExitY = height*tileSize;
                }
            }

            function drawCoin(x, y) {
                tx = x - 2;
                ty = y - 4;

                context.fillStyle = "#FFD300";
                context.fillRect(x,y+2,5,5);
                context.fillRect(x+1,y,3,9);
            }


            function drawEllipseByCenter(ctx, cx, cy, w, h, color) {
                drawEllipse(ctx, cx - w/2.0, cy - h/2.0, w, h);
            }

            function drawEllipse(ctx, x, y, w, h) {
                var kappa = .5522848,
                ox = (w / 2) * kappa, // control point offset horizontal
                oy = (h / 2) * kappa, // control point offset vertical
                xe = x + w,           // x-end
                ye = y + h,           // y-end
                xm = x + w / 2,       // x-middle
                ym = y + h / 2;       // y-middle

                ctx.fillStyle = "#6593F5";

                ctx.beginPath();
                ctx.moveTo(x, ym);
                ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                //ctx.closePath(); // not used correctly, see comments (use to close off open path)
                ctx.fill();
            }

            function drawLight(ctx, cx, cy, r) {
                ctx.fillStyle = "#000000";
                ctx.fillRect(0,0,overlay.width,overlay.height);

                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.clip();
                ctx.clearRect(0, 0, overlay.width, overlay.height);
                ctx.restore();

                if (!noExit) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(centerExitX, centerExitY, 35, 0, 2 * Math.PI);
                    ctx.clip();
                    ctx.clearRect(0, 0, overlay.width, overlay.height);
                    ctx.restore();
                }
            }


            /*
            ==================================================
            Start of the fireworks code, this is not mine, I used the code provided by http://seowebsitedesigning.com/create-fireworks-effect-using-html5-canvas/
            I do not take the credit of writing this piece of code whatshowever!!!
            ==================================================
            */


            function startFireworks() {
                var screenWidth = window.innerWidth;
                var screenHeight = window.innerHeight;

                var minVx = -10;
                var deltaVx = 20;
                var minVy = 25
                var deltaVy = 15;
                var minParticleV = 5;
                var deltaParticleV = 5;

                var gravity = 1;

                var explosionRadius = 200;
                var bombRadius = 10;
                var explodingDuration = 100;
                var explosionDividerFactor = 10; // I couldn't find a better name. Got any?

                var nBombs = 1; // initial
                var percentChanceNewBomb = 5;

                // Color utils forked from http://andreasstorm.com/
                // (or someone who forked from there)

                function Color(min) {
                    min = min || 0;
                    this.r = colorValue(min);
                    this.g = colorValue(min);
                    this.b = colorValue(min);
                    this.style = createColorStyle(this.r, this.g, this.b);
                };

                function colorValue(min) {
                    return Math.floor(Math.random() * 255 + min);
                }

                function createColorStyle(r,g,b) {
                    return 'rgba(' + r + ',' + g + ',' + b + ', 0.8)';
                }

                // A Bomb. Or firework.
                function Bomb(){
                    var self = this;
                    
                    self.radius = bombRadius;
                    self.previousRadius = bombRadius;
                    self.explodingDuration = explodingDuration;
                    self.hasExploded = false;
                    self.alive = true;
                    self.color = new Color();
                    
                    self.px = (window.innerWidth / 4) + (Math.random() * window.innerWidth / 2);
                    self.py = window.innerHeight;
                    
                    self.vx = minVx + Math.random() * deltaVx;
                    self.vy = (minVy + Math.random() * deltaVy) * -1; // because y grows downwards

                    self.duration = 

                    self.update = function(particlesVector){
                        if(self.hasExploded){
                        var deltaRadius = explosionRadius - self.radius;
                        self.previousRadius = self.radius;
                        self.radius += deltaRadius / explosionDividerFactor;
                        self.explodingDuration--;
                        if(self.explodingDuration == 0){
                            self.alive = false;
                        }
                        }
                        else{
                        self.vx += 0;
                        self.vy += gravity;
                        if(self.vy >= 0){ // invertion point
                            self.explode(particlesVector);
                        }

                        self.px += self.vx;
                        self.py += self.vy;
                        }
                    };

                    self.draw = function(ctx){
                        ctx.beginPath();
                        ctx.arc(self.px, self.py, self.previousRadius, 0, Math.PI * 2, false);
                        if(self.hasExploded){
                        }
                        else{
                        ctx.fillStyle = self.color.style;
                        ctx.lineWidth = 1;
                        ctx.fill();
                        }
                        
                    };
                    

                    self.explode = function(particlesVector){
                        self.hasExploded = true;
                        var e = 3 + Math.floor(Math.random() * 3);
                        for(var j = 0; j < e; j++){
                        var n = 10 + Math.floor(Math.random() * 21); // 10 - 30
                        var speed = minParticleV + Math.random() * deltaParticleV;
                        var deltaAngle = 2 * Math.PI / n;
                        var initialAngle = Math.random() * deltaAngle;
                        for(var i = 0; i < n; i++){
                            particlesVector.push(new Particle(self,  i * deltaAngle + initialAngle, speed));
                        }
                        }
                    };
                    
                    }

                    function Particle(parent, angle, speed){
                    var self = this;
                    self.px = parent.px;
                    self.py = parent.py;
                    self.vx = Math.cos(angle) * speed;
                    self.vy = Math.sin(angle) * speed;
                    self.color = parent.color;
                    self.duration = 40 + Math.floor(Math.random()*20);
                    self.alive = true;

                    self.update = function(){
                        self.vx += 0;
                        self.vy += gravity / 10;

                        self.px += self.vx;
                        self.py += self.vy;
                        self.radius = 3;

                        self.duration--;
                        if(self.duration <= 0){
                        self.alive = false;
                        }
                    };

                    self.draw = function(ctx){
                        ctx.beginPath();
                        ctx.arc(self.px, self.py, self.radius, 0, Math.PI * 2, false);
                        ctx.fillStyle = self.color.style;
                        ctx.lineWidth = 1;
                        ctx.fill();
                    };

                }

                function Controller(){
                    var self = this;
                    self.canvas = document.getElementById("fireworks");
                    self.canvas.width = screenWidth;
                    self.canvas.height = screenHeight;
                    self.ctx = self.canvas.getContext('2d');

                    function setSpeedParams(){
                        var heightReached = 0;
                        var vy = 0;

                        while(heightReached < screenHeight && vy >= 0){
                        vy += gravity;
                        heightReached += vy;
                        }

                        minVy = vy / 2;
                        deltaVy = vy - minVy;

                        vx = (1 / 4) * screenWidth / (vy / 2);
                        minVx = -vx;
                        deltaVx = 2*vx;
                    };

                    

                    self.resize = function(){
                        screenWidth = window.innerWidth;
                        screenHeight = window.innerHeight;
                        self.canvas.width = screenWidth;
                        self.canvas.height = screenHeight;
                        setSpeedParams();
                    };
                    self.resize();

                    window.onresize = self.resize;

                    self.init = function(){
                        self.readyBombs = [];
                        self.explodedBombs = [];
                        self.particles = [];

                        for(var i = 0; i < nBombs; i++){
                        self.readyBombs.push(new Bomb());
                        }
                    }

                    self.update = function(){
                        var aliveBombs = [];
                        while(self.explodedBombs.length > 0){
                        var bomb = self.explodedBombs.shift();
                        bomb.update();
                        if(bomb.alive){
                            aliveBombs.push(bomb);
                        }
                        }
                        self.explodedBombs = aliveBombs;

                        var notExplodedBombs = [];
                        while(self.readyBombs.length > 0){
                        var bomb = self.readyBombs.shift();
                        bomb.update(self.particles);
                        if(bomb.hasExploded){
                            self.explodedBombs.push(bomb);
                        }
                        else{
                            notExplodedBombs.push(bomb);
                        }
                        }
                        self.readyBombs = notExplodedBombs;

                        var aliveParticles = [];
                        while(self.particles.length > 0){
                        var particle = self.particles.shift();
                        particle.update();
                        if(particle.alive){
                            aliveParticles.push(particle);
                        }
                        }
                        self.particles = aliveParticles;
                    }

                    self.draw = function(){
                        self.ctx.beginPath();
                        self.ctx.fillStyle='rgba(0, 0, 0, 0.1)'; // Ghostly effect
                        self.ctx.fillRect(0, 0, self.canvas.width, self.canvas.height);
                        
                        
                        
                        for(var i = 0; i < self.readyBombs.length; i++){
                        self.readyBombs[i].draw(self.ctx);
                        }

                        for(var i = 0; i < self.explodedBombs.length; i++){
                        self.explodedBombs[i].draw(self.ctx);
                        }

                        for(var i = 0; i < self.particles.length; i++){
                        self.particles[i].draw(self.ctx);
                        }

                    }

                    self.animation = function(){
                        self.update();
                        self.draw();
                        
                    if(Math.random() * 100 < percentChanceNewBomb) {
                        self.readyBombs.push(new Bomb());
                    }
                        
                            
                        requestAnimationFrame(self.animation);
                    }
                }

                var controller = new Controller();
                controller.init();
                requestAnimationFrame(controller.animation);
            }
        } 
    </script>
</body>
